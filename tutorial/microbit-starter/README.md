# チュートリアル：micro:bitで始めるGameControllerizer 

それではGameControllerizerをmicro:bitで遊んでいきましょう。本チュートリアルによって、基本的な使い方から、少し発展的なことまで学べます。

## 準備するもの
- パソコン  
  - Windows PC ★1 （USBコネクタが２つ以上あるものがよいです★2）  
- ハードウェア
  - GameControllerizer基板  
  - Groveコネクタケーブル  
  - micro:bit  
  - micro:bit Groveシールド  
  - USBケーブル（PCとmicro:bitをつなぐ。micro:bitに給電し、プログラムを書き込むためのもの。）  
  - USBケーブル（PCとGameControllerizerをつなぐ。ゲームコントローラとしてPCに操作指示を送るためのもの。）  
- ソフトウェア    
  - 好きなゲーム（ゲームパッドで動くもの）  
  
- ★１ macでもプログラミングはできます。しかしmacにはゲームパッドの概念がないので、ゲームパッドをキーボード入力に変換するもの   https://yukkurigames.com/enjoyable/ を用いるか、別のゲーム機を用意してください。  
- ★2 USBコネクタが１つしかないPCの場合、micro:bitにプログラムを書き込みたいときと、ゲームコントローラとして遊びたいときでUSBケーブルを選んで抜き差しすれば大丈夫です。  

## 接続
まず図のようにハードウェアを接続します。  

PC --> USB --> micro:bit --> micro:bit Groveシールド --> Groveコネクタケーブル（P0/P14へ接続） --> GameControllerizer基板 --> USBケーブル --> PC

## micro:bitについて
micro:bitのプログラミングやダウンロードの仕方が全くわからない方は、以下を見てください。  
https://microbit.org/ja/guide/quick/  
以下、micro:bitのプログラミングとダウンロードの方法は最低限理解した前提で進めます。  

## 最初のGameControllerizerサンプル
以下のリンクを開いてください。    
https://makecode.microbit.org/_bDM1vqTRgHK5  
基本的には、このようにmicro:bitの通常のプログラミングの中に、GameControllerizer独自のブロックたちを組み込むことでゲームコントローラのプログラミングを進めていきます。簡単ですね！  

「編集」を押してください。このサンプルプログラムを、自分のプログラムとしてコピーして編集できるようになります。
自分のmicro:bitにダウンロードして、動作確認してみましょう。micro:bitを左右に傾けると、LEDがその向きの矢印表示になり、またAボタンを押すと"A"と表示されるはずです。GameControllerizerをゲーム機に接続すれば、そのとおりの動作をするはずです。左右移動と１ボタンしかないので、今のままではスペースインベーダーくらいしかできませんね★
最低限の体験をしていただきたかったので、まだポンコツコントローラです！これから皆さん自身の手で本格的に仕上げていきます。

## プログラミング環境を見てみよう
プログラムと、プログラミングのための環境(makecode)を見てください。画面中央左寄りに様々なプログラミングの部品のリストがありますが、「GameControllerizer」という項目がありますね。ここがGameControllerizer独自のブロックです。現時点で２ページぶんあり、「その他」にも重要なブロックがたくさんありますのでお見逃しなく！

###### **【参考：最初は読まなくて良い】**  このGameControllerizer関連ブロックの項目は、「拡張機能」というmicro:bitのしくみでつくられており、通常のmicro:bitプログラミングでは最初からは存在しません。今回のようにサンプルプログラムを「編集」ボタンにより自分のプログラムとしてコピーすれば使えるようになりますし、１からプログラミングしたい人は、エディタ画面の右上の歯車マークをクリックし、「拡張機能」の中で以下のURLをタイプすると、組み込めるようになります。https://github.com/GameControllerizer/pxt-gamecontrollerizer.git

## プログラミングを見てみよう
プログラムを眺めてみましょう。  
必要なお約束が１つあり、「最初だけ」のところに「GCモジュールをGroveコネクタXXに接続」を作り、XXの部分は実際に自分のmicro:bitにケーブルをつないだ端子を選ぶ、ということです。
それ以外は、基本的には「〜のボタンを押す」のようなブロックがほとんどなので、特に難しくないと思います。
当面、扱うブロックは、

- ボタンを扱う  
- 十字キーを扱う  
- アナログスティックを扱う  

だけで大丈夫だと思います。ここで、  

- 十字キーおよびアナログスティックには、「押す」「押し続ける」の２種類  
- ボタンには「押す」「押し続ける」「離す」の３種類  

の指示ができます。「押す」はポンっと短くボタンを押して離す作業です。「押し続ける」は「離す」と対になっており、押している状態の継続と解除を指定できます。

- 十字キーは、「中央」を「押し続ける」ことが、「離す」に相当します。
- アナログスティックは、「０，０」を「押し続ける」ことが、「離す」に相当します。

###### **【参考：最初は読まなくて良い】**  押すと「押し続ける/離す」は実は大きな違いがあります。「押す」は「押し続ける」→少し待つ→「離す」の動作を簡単に指定できるもの、と考えることができますが、少し待っている間、別のコントローラ操作指示を受け付けません。つまり完全に仕事をサボってしまうんです。ですから、ドラゴンクエストでコマンドを入力するときのような、同時に押されるボタンの数がせいぜい１つ以下のときに使うとよいです。一方「押し続ける/離す」は瞬時に効果が反映されるので、同時進行でいくつもの指示が来ても対応できます。

## ボタンをゲームに対応づけたい
ちょっと面倒だけど必ず考えなければならないのが、ボタンの対応づけです。
GameControllerizerは0から11まで番号のついたボタンを扱えますが、何番のボタンがゲーム機のどのボタンに対応するかは、ゲーム機ごとに違います。以下によく用いられるxboxとNintendo Switchの対応表を書きますので、参考にしてください。わからなくても実際にゲーム機とつないで、一つ一つボタンを試してみれば、調べることができますね。

| ボタン番号 |    xboxボタン | Switchボタン |
----|----|----
| 0 |    left bumper | Y |
| 1 |    right bumper | X |
| 2 |    left trigger | ZL |
| 3 |    right trigger | ZR |
| 4 |    back | L |
| 5 |    start | R |
| 6 |    left stick | L stick |
| 7 |    right stick | R stick |
| 8 |    X | + |
| 9 |    A | - |
| 10 |    B | B |
| 11 |    Y | A |

## もっと本格的なコントローラに！
さあ、ポンコツコントローラに対して、まず皆さんは以下のことがやりたいはずです。どうすればできるでしょうか。考えてみましょう
- 左右どちらにも動かない「止まっている」状態を作りたい
- ボタンを追加したい

プログラム例：https://makecode.microbit.org/_fYWYKEKjpeAJ  
ちなみに、micro:bitにボタンは２つしかありませんが、「P1をタッチ」「P2をタッチ」を使えば、４ボタンまではすぐに増やせますね。

次にやりたいのは、以下のようなことでしょうか。
- アナログスティックを使いたい
- ボタンの「押しっぱなし」を実現したい  

プログラム例：https://makecode.microbit.org/_LzJ7iJ4koTYR

アナログスティックは(0,0)をニュートラル状態として、x軸y軸ともに-127~127の値で傾きを指示します。
また、「Aボタンが押されたら」の代わりに「ずっと」のループの中でmicro:bitボタンの状態を検出するようにすることで、ボタンを押しっぱなしにする指示が実現できます。これでマリオが高くジャンブできたり、レーシングゲームでアクセルを踏み続けることができるようになります。

## 反応速度を上げたい
地味なようで奥が深いのがこのトピックです。
先程のアナログスティックとボタンの「押しっぱなし」の例は、最初に紹介した「最初のGameControllerizerサンプル」よりもきびきびと動作するはずです。
プログラムの書き方によって、この「きびきび感」は大きく変わります。ゲームコントローラは皆さんの体の一部となってゲームと皆さんをつなぎますから、ここを真剣に考えることがとても重要です。よく理解し、良い「ユーザ体験」を実現させましょう。

### (1-1)「ボタンが押されなくなったとき」がない！
先程のアナログスティックのプログラムをもう一度見てみましょう。  
https://makecode.microbit.org/_LzJ7iJ4koTYR  

現在プログラミングに使っているmakecode.microbit.orgバージョン：1.2.13では、「Xボタンが押されたとき」というブロックはあるのに、「Xボタンが押されなくなったとき」というブロックがありません。ボタンの「押しっぱなし」を実現するために、「ずっと」のループの中でボタンの状態を検出し、それに対応した指示を出すようにしました。アナログスティックスティックについても、microbitの傾きを加速度センサで検出することを毎回のループで行っています。

これで万事解決のようですが・・実は少し問題があります。

###### **【参考：最初は読まなくて良い】**  ちなみに「端子XXがタッチされたとき」と「端子XXがタッチされなくなったとき」はなぜかあるので、タッチ入力については「ずっと」のループの中に処理を書かなくても大丈夫な感じがしますが、試してみたところうまく動作しません。おそらく、「タッチされたとき」は「タッチして、タッチをやめたとき」に反応するようになっているのでしょう。 実験例：  https://makecode.microbit.org/_dooJ0jAt8AT1  

### (1-2)「速すぎ」も問題
アナログスティックとボタンの「押しっぱなし」の例では、「ずっと」のループの中でGameControllerizerへの指示を書いていました。
実際に動作させてみると、GameControllerizerの基板上のオレンジLEDが激しく点滅していることがわかると思います。これはつまり、ものすごい速さで「ずっと」のループが繰り返されて、GameControllerizerへの操作指示が高速に出ていることを意味しています。実はこれ、かなり「ギリギリ動いている」という状態なんです。
GameControllerizerは、操作指示が大量に送りつけられると、処理が間に合わなくなったり遅れたりしてしまいます。

以下のコードを試してみてください。  
 https://makecode.microbit.org/_3fwAYmATwARX  
「ずっと」のループによって、すごい速さで常にたくさんの指示をGameControllerizerに送りつけているので、処理が間に合わず「もっさり」してしまっています。

これに対処するには、簡単な方法としっかりやる方法の２通りがあります。

#### （あ）簡単な方法は、「ずっと」のループが速く回りすぎないよう、「休み」を入れることです。
「基本」ブロックの「一時停止（ミリ秒）」で最小の選択肢である100ミリ秒の休みを入れることで、だいぶ落ち着きます。  
 https://makecode.microbit.org/_68LVuqfXrYkg  

###### **【参考：最初は読まなくて良い】**  100ミリ秒の一時停止を入れるということは、1秒あたり10回程度操作を受け付ける、ということですから、10fpsです。本格ゲーマーの皆さんなら、ちょっと雑すぎて話になりませんよね。その場合は、「高度なブロック」の「制御」の中にある「全体を一時停止（マイクロ秒）」を使えば、より細かい時間を指定できます。GameControllerizerは基本は60fps動作なので、1/60秒である16666マイクロ秒が、だいたい最小の値でしょうか。なお、GameControllerizerがどれだけ高速で頑張っても、ゲーム機側が8ミリ秒(8000マイクロ秒）周期で動いていたりするので、高速化にも限界はあります。詳しくは「USB コントローラ ポーリングレート」などで検索してみてください。さらに余談ですが、本格ゲーマーはこの「ポーリングレート」を限界まで小さくして、遅延の少ない操作を実現しようとしているようです。すごい！

###### **【参考：最初は読まなくて良い】** 　GameControllerizerのブロックに「Xフレーム待つ」というものがあります。これも「休み」に使えそうですが、そう単純ではありません。これはGameControllerizerがゲーム機へと送る信号をX/60秒待つ、というだけなので、仮にこの命令を「ずっと」で送り続けると、micro:bitからGameControllerizerへの通信が飽和してしまいます。

#### （い）しっかりやる方法は、変数をつかって現在のボタンの状態を管理し、変化があったときだけGameControllerizerへと指示を送り、通信量を削減することです。
作例は割愛します。

### （2）micro:bitのLED表示は「遅い」
micro:bitにはLEDがあるので、コントローラの状態表示させたくなりますよね。そこで以下の2つを比べてみてください。  
- LED表示とGameControllerizer指示が直列につないであるもの https://makecode.microbit.org/_UDbUvw5rmM8V  
- LED表示とGameControllerizer指示が別の「ずっと」の中にあるもの https://makecode.microbit.org/_KXueWi2rx5zv  

後者のほうがずっとコントローラ側の反応が早いですよね！micro:bitのLED表示は、完了まで時間がかかるということです。LEDを使いたい場合は、処理が遅くならないよう注意しましょう。

## そして「そこそこ動く」バージョンの完成！  
これまでの学習を通じて、「なるべくたくさんのボタンがつかえて、もっさりしない」コントローラプログラムを完成させましょう。  

- 十字キー入力を行う作例  
https://makecode.microbit.org/_YY9DgzUDUdmd  
- アナログスティックによる入力を行う作例  
https://makecode.microbit.org/_68LVuqfXrYkg  

## その他のトピック  
### 無線通信したい
micro:bitが複数あれば、無線通信できるので手作りゲームコントローラ自体を無線化できますし、micro:bitの少ないボタンやセンサ数を増強して、より豊かなゲーム制御ができるようになります。
以下はswitch-educationが公開している、micro:bit 2つを用いたラジコンカーの作例ビデオです。  
https://www.youtube.com/watch?v=KQ2IDCQli7A&feature=youtu.be  
ラジコンカーのコントローラは、そのままマリオカートなどのコントローラとして活用できますね。送信側と受信側の２つのプログラムがありますが、送信側はそのままで、受信側を少し改造し、モーターへの指示の部分をGameControllerizerへの指示に変えれば、無線ゲームコントローラの出来上がりです！

### コマンド入力したい
（作成中）  

### お役立ちリンク：
- x360ce:　windowsの「コントローラエミュレータ」で、ゲームパッドのボタンが押されてたことを視覚的に教えてくれるチェックソフトです。
  - https://www.x360ce.com/　
